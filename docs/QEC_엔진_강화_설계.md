## 1. 목표 및 범위

이 문서는 `sfe_core` 엔진 내 QEC(Repetition Code 및 향후 Surface Code) 모듈을,  
SFE 이론(억압장 기반 1/f 노이즈 모델)과 실제 양자 하드웨어 특성(T1, 게이트, 측정 에러 등)에 맞추어  
**공간 상관 노이즈, 시간축 디코더, 코드 구조, 캘리브레이션 연동** 측면에서 단계적으로 고도화하기 위한 설계 문서이다.

본 설계는 다음 네 축을 모두 포함한다.

- **채널/노이즈 축**: 1/f 위상 노이즈 → 공간 상관 1/f 노이즈(공통 모드 + 개별 모드) 확장
- **디코더/시간축 축**: 단일 라운드 다수결 → 시간-공간 그리드 상 최소 경로/동적계획 디코더
- **코드 구조 축**: 1D 반복 코드 → 소형 Surface Code(d=3) 추가
- **장치 파라미터 축**: 레퍼런스 값 → 실제 T1/T2, 게이트·측정 오류 JSON 연동

각 섹션은 수학적 정의, 구현 전략, 그리고 기존 코드(`qec.rs`, `noise.rs`)와의 연결 지점을 명시한다.


## 2. 현재 구현 상태 요약

### 2.1 채널/노이즈 모델

현재 `qec.rs`는 다음 네 종류의 채널을 포함한다.

1. **위상 노이즈(1/f\^α)**  
   - `PinkNoiseGenerator::new_with_params(steps, alpha, scale)` 에 의해 생성된 시계열 노이즈 `noise[t]` 사용
   - SFE 펄스 시퀀스에 의해 정의된 토글 함수 $y(t)\in\{+1,-1\}$ 에 대해
     $$
     \phi = \sum_t y(t)\,\delta\Phi(t)\,\Delta t
     $$
   - 위상에 의한 에러 확률
     $$
     p_{\text{phase}} = \frac{1 - \cos\phi}{2}
     $$

2. **T1(에너지 붕괴) 채널**  
   - `.env`의 `SFE_T1_STEPS` 를 읽어, $T_1$에 해당하는 시간 스텝 수로 사용 ($\text{기본값}=10^5$)  
   - QEC 한 주기 길이 $\Delta t = \text{measure\_interval}$ 에 대해
     $$
     p_{T1} = 1 - e^{-\Delta t/T_1}
     $$

3. **게이트 오류 채널**  
   - `.env`의 `SFE_GATE_ERROR` 를 주기당 게이트 에러율로 사용 ($\text{기본값}\approx10^{-3}$)

4. **측정 오류 채널**  
   - `.env`의 `SFE_MEAS_ERROR` 를 각 큐비트 신드롬 플립 확률로 사용 ($\text{기본값}\approx10^{-3}$)

각 QEC 사이클에서 각 큐비트 $q$에 대해, 위상·T1·게이트 채널은 독립 채널로 간주되어

$$
p_{\text{tot}}(q) = 1 - \big(1 - p_{\text{phase}}\big)\big(1 - p_{T1}\big)\big(1 - p_{\text{gate}}\big)
$$

로 결합되고, 이후 측정 오류에 의해 신드롬 플립이 발생한다.


### 2.2 반복 코드 QEC 구조

현재 반복 코드 QEC는 다음과 같다.

- **코드 구조**: 거리 $d$ 의 1D 반복 코드 (홀수, $d=\text{distance}$)
- **QEC 주기**: `measure_interval` 스텝마다 한 번씩 보정 라운드를 수행
- **디코더(현재 단순 버전)**:
  - 각 주기마다 큐비트별 물리 에러 발생 여부(`error_flags[q]`)를 얻고
  - 에러 개수가 $>\frac{d}{2}$ 이면 해당 trial을 논리 실패로 판정
  - 시간축 정보를 활용하지 않고, 각 라운드를 독립 이벤트로 간주

이 구조는 **임계값 개념(임계 노이즈 아래에서 QEC가 이득, 위에서 악화)**을 정성적으로 재현하지만,  
실제 QEC에서 사용하는 시간-공간 디코더(여러 라운드의 신드롬 패턴을 보고 에러 경로를 추론)는 아직 구현되지 않았다.


### 2.3 SFE와 QEC의 결합 방식

SFE 레이어는 `optimizer.rs`에서 최적화된 펄스 시퀀스(정규화 비율 $\{r_j\}$)를 `steps`에 매핑하여  
정수 인덱스 $\{t_j\}$를 생성한다.

QEC에서는 이 인덱스를 QEC 주기 길이 `measure_interval` 에 대해 모듈러 연산하여

$$
t_j^{(\text{cycle})} = t_j \bmod \text{measure\_interval}
$$

형태의 **한 주기 내 펄스 패턴**으로 변환한 뒤,  
각 QEC 주기마다 동일한 패턴이 반복 적용되는 것으로 모델링한다.

이렇게 함으로써, SFE 필터 함수 설계(연속 시간)와 QEC 반복 구조(이산 시간, 주기 반복)가  
일관된 방식으로 결합된다.


## 3. 공간 상관 1/f 노이즈 확장 설계

### 3.1 물리적 동기

현재 `PinkNoiseGenerator`는 단일 시계열을 생성하며, 각 큐비트 노이즈는 **독립**으로 모델링된다.  
그러나 실제 초전도 칩에서는 다음과 같은 특성이 관측된다.

- 공통 모드 노이즈: 모든 큐비트에 거의 동일하게 작용하는 저주파 배경 플럭스
- 인접 큐비트 간 상관: 물리적 근접도, 배선 구조에 따라 1/f 잡음의 상관 계수 $\rho_{ij}$가 0이 아님

이를 반영하기 위해, 주파수 도메인에서 공분산 행렬 $C_{ij}$ 를 도입한 **벡터 Pink 노이즈**가 필요하다.


### 3.2 수학적 정식화

단일 큐비트의 1/f 노이즈 스펙트럼은

$$
S_\Phi(\omega) = \frac{A}{\omega^\alpha}
$$

로 쓴다. 여러 큐비트 $i,j$ 간의 상관을 포함하면

$$
S_{\Phi,ij}(\omega) = \frac{A}{\omega^\alpha} C_{ij}
$$

여기서 $C_{ij}$는 정규화된 상관 행렬 ($C_{ii}=1$) 이다. 간단한 모델로는

$$
C_{ij} = \rho + (1-\rho)\,\delta_{ij}
$$

처럼 공통 모드 비율 $\rho\in[0,1]$ 을 도입할 수 있다.

푸리에 모드별로, 위상 잡음의 복소 진폭 $\tilde{\Phi}_k$는 공분산 $\propto C_{ij}$ 를 따르는 가우시안 난수로 생성된다.


### 3.3 구현 전략 (`noise.rs` 확장)

1. **새 구조체 도입**: `CorrelatedPinkNoiseGenerator`  
   - 필드: 큐비트 수 `n_qubits`, 스텝 수 `steps`, 상관 계수 `rho`, 스펙트럼 파라미터 `(alpha, scale)`
   - 내부에 `Vec<Complex<f64>>` 형태의 스펙트럼 버퍼를 `n_qubits` 개 보유

2. **주파수 도메인에서 상관 부여**:
   - 각 모드 $k$에 대해, 독립 표준 정규 벡터 $\mathbf{z}_k\in\mathbb{R}^{n\_q}$ 생성
   - 상관 행렬 $C$의 촐레스키 분해 $C = LL^\top$ 를 미리 계산
   - $\mathbf{y}_k = L \mathbf{z}_k$ 를 취해 원하는 공분산을 가진 샘플 생성
   - 각 큐비트 $i$에 대해
     $$
     \tilde{\Phi}_{i,k} = y_{i,k}\,\frac{\text{scale}}{f_k^{\alpha/2}}
     $$

3. **역 FFT로 시간 영역 노이즈 벡터 생성**:
   - 각 큐비트 $i$에 대해 $\tilde{\Phi}_{i,k}$ 를 IFFT하여 $\Phi_i(t)$ 얻기

4. **QEC와의 연동**:
   - `simulate_repetition_code`에서 현재 `traces: Vec<Vec<f64>>` 를 생성하는 부분을  
     `CorrelatedPinkNoiseGenerator`로 교체하여,  
     동일 trial에서 모든 큐비트가 상관된 노이즈를 받도록 변경

이렇게 하면, **멀티 큐비트 상관 잡음 + SFE + 반복 코드 QEC**를 동시에 시뮬레이션할 수 있다.


## 4. 시간-공간 디코더 설계 (반복 코드)

### 4.1 필요성

현재 디코더는 각 QEC 사이클마다

- 에러 개수 $>$ $d/2$ → 논리 실패

만을 보고, 시간축 상에서 에러가 어느 시점에 발생했는지는 고려하지 않는다.  
그러나 실제 QEC에서는 **여러 라운드의 신드롬 패턴**을 보고, 에러 궤적(trajectory)을 추론하는 디코더를 사용한다.


### 4.2 2D 그리드 표현

거리 $d$ 반복 코드를 시간축 $T$ (사이클 수 $N\_c$) 동안 실행하면,  
에러 패턴은 $d\times N\_c$ 격자 상의 이진 변수

$$
e_{q,c} \in \{0,1\},\quad q=0,\dots,d-1,\quad c=0,\dots,N_c-1
$$

으로 표현된다.

신드롬은 이 에러 플래그의 차분(혹은 인접 XOR)으로 정의되며,  
시간-공간 그래프 상에서의 에러 경로는 가중치가 부여된 엣지 집합으로 볼 수 있다.


### 4.3 간단한 동적 계획 디코더 설계

완전한 MWPM(minimum-weight perfect matching) 대신, 반복 코드에 특화된 간단한 디코더를 설계할 수 있다.

1. **모델**: 각 시간 슬라이스마다, 가능한 물리 에러 패턴 후보(예: 단일 에러, 인접 두 개 에러)를 제한된 집합으로 둔다.
2. **전이**: $c\to c+1$ 로 진행하면서, 후보 상태 간 전이 비용(누적 Hamming weight)을 동적 계획법으로 계산.
3. **최종 상태 선택**: 마지막 사이클에서 최소 비용 경로를 택해, 해당 경로에 따른 **논리 연산(논리 플립 여부)**를 판정.

이를 통해, 시간축 상의 누적 에러가 단순 다수결보다 더 정교하게 처리되어,  
특히 **임계값 근처에서의 QEC 이득곡선**이 실제 논문 결과와 더 잘 맞게 된다.


## 5. Surface Code(d=3) 시뮬레이터 설계

### 5.1 코드 패치 및 안정자

최소 유효 surface code는 거리 $d=3$ 패치로,

- 물리 큐비트 수: 9개(혹은 17개 버전)를 사용할 수 있음
- 안정자(안전 연산자)는 X형, Z형 각각 4개 이상

예를 들어, 9-큐비트 distance 3 패치에서,

- Z-안정자: 네 개의 4-큐비트 플라켓에 해당
- X-안정자: 이중 구조

이 안정자 측정 결과(신드롬) 패턴으로부터 논리 X/Z 오류를 판정한다.


### 5.2 채널 매핑

기존 채널 모델(위상 + T1 + 게이트 + 측정)을 surface code에 그대로 적용하려면:

1. **게이트 스케줄**: surface code의 한 라운드를 구성하는 CNOT, Hadamard, 측정 연산 시퀀스 정의
2. **채널 삽입 시점**:
   - 각 게이트 이후 depolarizing-like 오류
   - idle 구간에 T1/T2 적용
   - 측정 시점에 측정 오류 삽입
3. **위상 노이즈와의 결합**:
   - 위상 노이즈는 Z오류로, T1은 X/Y 성분을 포함한 relax 채널로 매핑할 수 있음


### 5.3 간이 디코더

작은 d=3 surface code에 대해서는, 완전한 MWPM 대신

- 미리 정의된 소수의 에러 패턴(한두 개 큐비트 플립)에 대한  
  룩업 테이블 디코더를 사용할 수 있다.

이렇게 하면, **SFE 필터링 + surface code QEC** 의 엔드투엔드 효과를  
상당히 적은 구현 비용으로 수치 평가할 수 있다.


## 6. 실제 캘리브레이션 파라미터 연동 설계

### 6.1 IBM Fez 캘리브레이션 JSON

IBM Backend는 일반적으로 REST API나 Qiskit 인터페이스를 통해  
다음과 같은 정보를 제공한다.

- T1, T2: 각 큐비트별 에너지·위상 감쇠 시간
- 게이트 에러율: 각 단일/2큐비트 게이트별 에러 확률
- 측정 에러율: 각 큐비트별 읽기 오류 확률

이를 `.json` 혹은 Qiskit `backend.properties()` 형태로 획득한 뒤,  
`sfe_core`의 `.env` 및 내부 파라미터로 매핑한다.


### 6.2 매핑 규칙

- `SFE_T1_STEPS`:
  - 기본 시간 단위를 엔진의 한 스텝에 해당하는 $\Delta t$로 두었을 때,
  - 특정 큐비트의 $T_1$ (초)와 시뮬레이터의 $\Delta t$(초/스텝)를 곱하여
    $$
    T1_{\text{steps}} = \frac{T_1}{\Delta t}
    $$
  - 여러 큐비트가 있을 경우, 최소값 혹은 평균값을 사용

- `SFE_GATE_ERROR`, `SFE_MEAS_ERROR`:
  - Qiskit `backend.properties()`에서 해당 에러율을 추출해 그대로 사용  
  - 튜닝이 아니라 “측정값을 그대로 넣는 것”이므로, 연역성 위배 없음


### 6.3 구현 경로

1. `sfe_core` 바깥(Python 측)에서 Qiskit으로 Fez의 properties를 읽어 JSON으로 저장
2. `info/` 혹은 `docs/` 경로에 이 JSON을 배치
3. 엔진 실행 전, 별도 Python 유틸리티(예: `examples/quantum/load_calibration.py`)에서
   - JSON을 파싱해 `.env` 혹은 환경변수에 `SFE_T1_STEPS`, `SFE_GATE_ERROR`, `SFE_MEAS_ERROR`를 설정
4. 이후 `sfe_core`는 **환경 변수만 읽어** 시뮬레이션 수행 → 코드 자체는 변하지 않음

이 과정을 통해, **실제 장치 캘리브레이션 데이터 기반 SFE+QEC 시뮬레이션**이 가능해진다.


## 7. 환경 변수 및 인터페이스 정리

### 7.1 환경 변수 목록

- `SFE_NOISE_ALPHA`: 1/f 노이즈 스펙트럼 기울기 $\alpha$ (기본값 0.8)
- `SFE_NOISE_SCALE`: 1/f 노이즈 전체 세기 스케일 (기본값 1.5 × noise\_level)
- `SFE_MOMENT_ORDER`: 저주파 모멘트 패널티에 포함할 차수 (0~3, 기본값 3)
- `SFE_T1_STEPS`: T1 수명(스텝 단위, 기본값 1e5)
- `SFE_GATE_ERROR`: QEC 주기당 게이트 오류율 (기본 1e-3)
- `SFE_MEAS_ERROR`: 측정(신드롬) 오류율 (기본 1e-3)

### 7.2 QEC CLI 인터페이스

`sfe_core` 바이너리의 `Qec` 서브커맨드는 다음 인자를 받는다.

- `--distance d`: 반복 코드 거리 (홀수)
- `--noise x`: 위상 노이즈 진폭 (엔진 내부에서 `SFE_NOISE_SCALE`과 함께 사용)
- 내부적으로 SFE 최적화 엔진에서 펄스 시퀀스를 얻은 뒤,  
  위에서 정의한 멀티 채널 QEC 시뮬레이터를 호출해 `QECResult`를 반환한다.

이 설계 문서를 바탕으로, 차후 PR에서는 다음 순서로 고도화를 진행할 수 있다.

1. `CorrelatedPinkNoiseGenerator` 및 QEC에서의 사용
2. 반복 코드용 시간-공간 디코더 (동적계획 기반)
3. 소형 surface code(d=3) 시뮬레이터 및 간단 디코더
4. Fez 캘리브레이션 JSON 연동 유틸리티 작성

각 단계는 수학적 정의가 명확하므로, 추가적인 파라미터 튜닝 없이도  
SFE 이론의 연역적 검증과 QEC 레이어의 공학적 정교화를 동시에 달성할 수 있다.


