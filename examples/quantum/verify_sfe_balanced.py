import numpy as np
import matplotlib.pyplot as plt
from joblib import Parallel, delayed
import time

# --- SFE FINAL WEAPON V3 (Balanced Log-SFE from Rust Engine) ---
# Generated by sfe_engine v1.6
SFE_SEQ_BALANCED = np.array([
    0.0580, 0.1455, 0.2305, 0.3090, 0.3815, 0.4495, 0.5130, 0.5730, 
    0.6295, 0.6830, 0.7340, 0.7830, 0.8295, 0.8745, 0.9180, 0.9595
])

# CPMG-16 (Reference)
# (k - 0.5) / 16
CPMG_SEQ = (np.arange(1, 17) - 0.5) / 16

def generate_noise(steps, noise_type='pink', scale=1.0, rng_seed=None):
    rng = np.random.default_rng(rng_seed)
    
    if noise_type == 'dc':
        # Static Offset + Slow Drift
        dc = rng.standard_normal() * scale
        t = np.linspace(0, 1, steps)
        drift = np.sin(2 * np.pi * 0.5 * t) * (scale * 0.2) # Very slow drift
        return np.full(steps, dc) + drift
        
    elif noise_type == 'pink':
        # 1/f^1.5
        alpha = 1.5
        white = rng.standard_normal(steps)
        white_fft = np.fft.rfft(white)
        freqs = np.fft.rfftfreq(steps)
        scaling = np.ones_like(freqs)
        if len(freqs) > 1:
            scaling[1:] = 1.0 / (freqs[1:] ** (alpha / 2.0))
        pink = np.fft.irfft(white_fft * scaling, n=steps)
        return (pink / np.std(pink)) * scale
        
    return np.zeros(steps)

def calculate_phase_error(noise_trace, pulse_seq, total_time, coupling=0.01):
    if len(pulse_seq) == 0:
        return np.sum(noise_trace) * coupling

    pulse_indices = (pulse_seq * total_time).astype(int)
    pulse_indices = np.unique(pulse_indices)
    
    # Integration using Modulation Function y(t)
    # y(t) starts at +1, flips at each pulse
    # Efficient implementation
    y = np.ones(total_time)
    current_sign = 1.0
    last_idx = 0
    
    for p_idx in pulse_indices:
        if p_idx >= total_time: break
        y[last_idx:p_idx] = current_sign
        current_sign *= -1.0
        last_idx = p_idx
    y[last_idx:] = current_sign
    
    # Error = Integral(Noise * y(t))
    return np.sum(noise_trace * y) * coupling

def run_simulation(noise_type='pink'):
    print(f"\n=== Simulation: {noise_type.upper()} Noise ===")
    trials = 2000
    total_time = 5000
    noise_amp = 2.0 # Strong enough to cause errors
    
    modes = ['Raw', 'CPMG', 'SFE-Balanced']
    results = {m: 0 for m in modes}
    
    # Parallel execution
    def single_trial(seed):
        noise = generate_noise(total_time, noise_type, noise_amp, seed)
        res = {}
        
        # Raw
        phi_raw = calculate_phase_error(noise, [], total_time)
        res['Raw'] = 1 if abs(phi_raw) > np.pi/2 else 0
        
        # CPMG
        phi_cpmg = calculate_phase_error(noise, CPMG_SEQ, total_time)
        res['CPMG'] = 1 if abs(phi_cpmg) > np.pi/2 else 0
        
        # SFE
        phi_sfe = calculate_phase_error(noise, SFE_SEQ_BALANCED, total_time)
        res['SFE-Balanced'] = 1 if abs(phi_sfe) > np.pi/2 else 0
        
        return res

    seed_base = int(time.time())
    outcomes = Parallel(n_jobs=-1)(delayed(single_trial)(seed_base + i) for i in range(trials))
    
    # Aggregate
    for out in outcomes:
        for m in modes:
            results[m] += out[m]
            
    print(f"{'Mode':<15} | {'Error Rate':<10} | {'Performance'}")
    print("-" * 45)
    
    base_err = results['Raw'] / trials
    for m in modes:
        err = results[m] / trials
        gain = base_err / max(err, 1e-9)
        print(f"{m:<15} | {err:.4f}     | {gain:.1f}x gain")
        
    return results

def main():
    # 1. Verify DC Cancellation (Sanity Check)
    res_dc = run_simulation('dc')
    
    # 2. Verify Pink Noise Suppression (Real Deal)
    res_pink = run_simulation('pink')
    
    # Check
    err_cpmg = res_pink['CPMG']
    err_sfe = res_pink['SFE-Balanced']
    
    if err_sfe < err_cpmg:
        print("\n[SUCCESS] SFE-Balanced outperforms CPMG in Pink Noise!")
        print(f"Improvement: {(err_cpmg - err_sfe)/err_cpmg*100:.1f}%")
    else:
        print("\n[FAIL] CPMG is still better. Tuning needed.")

if __name__ == "__main__":
    main()

